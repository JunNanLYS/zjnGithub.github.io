<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>楠君的小窝</title>
  
  
  <link href="https://www.nanjun-blog.com/atom.xml" rel="self"/>
  
  <link href="https://www.nanjun-blog.com/"/>
  <updated>2023-03-18T02:35:37.857Z</updated>
  <id>https://www.nanjun-blog.com/</id>
  
  <author>
    <name>楠君的小窝</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python类属性与实例属性</title>
    <link href="https://www.nanjun-blog.com/posts/995a340e.html"/>
    <id>https://www.nanjun-blog.com/posts/995a340e.html</id>
    <published>2023-03-17T11:32:49.000Z</published>
    <updated>2023-03-18T02:35:37.857Z</updated>
    
    <content type="html"><![CDATA[<h1>类属性与实例属性</h1><p>类属性会在程序运行时运行，而实例属性则只会在实例化后运行。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;类属性&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类实例属性&quot;</span>)</span><br></pre></td></tr></table></figure><p>当我们什么都不做时，python会输出<code>类属性</code>，当我们将A实例赋值给a后，python输出<code>类实例属性</code>，并且python不会再输出一遍类属性。</p><p>这是一个值得注意的一个点。</p><p>当使用Qt之类的时，我们在类属性内实例化窗口会导致程序崩溃。你需要将QApplication置顶实例。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;类属性与实例属性&lt;/h1&gt;
&lt;p&gt;类属性会在程序运行时运行，而实例属性则只会在实例化后运行。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span </summary>
      
    
    
    
    <category term="Python" scheme="https://www.nanjun-blog.com/categories/Python/"/>
    
    <category term="PySide6" scheme="https://www.nanjun-blog.com/categories/Python/PySide6/"/>
    
    
    <category term="Python" scheme="https://www.nanjun-blog.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>蜂巢</title>
    <link href="https://www.nanjun-blog.com/posts/2406641d.html"/>
    <id>https://www.nanjun-blog.com/posts/2406641d.html</id>
    <published>2023-02-22T13:38:33.000Z</published>
    <updated>2023-03-18T02:35:37.858Z</updated>
    
    <content type="html"><![CDATA[<p>这是蓝桥杯2022年Python的G题，其实这道题我在很久之前看到时被劝退，感觉自己写不出来，今天重新来挑战他，发现这道题没有运用任何变成知识，仅仅运用了直角坐标系(笛卡尔坐标系)。</p><p>看到这一题的第一眼肯定不会将他和坐标系联系在一起，第一想到的时DFS和BFS这种搜索算法，但是很可惜，这道题没有这么深。</p><h1>解题思路</h1><h2 id="思路">思路</h2><p>根据图中显示，我们可以发现，从原点O(0, 0)出发，左上、左下、右上、右下，这4个方向每移动一次<code>x +- 0.5</code>, <code>y +- 1</code></p><p>而向左或者向右只有 <code>x +- 1</code></p><p>根据这个想法可以得出<code>[[-1, 0], [-0.5, 1], [0.5, 1], [1, 0], [0.5, -1], [-0.5, -1]]</code>，下标从0开始，每个下标都对应着蜂巢的6个方向。</p><p>按照题目给的要求得到点B和点C</p><p>计算两点之间的距离，两点之间的路径就是<code>abs(x1 - x2) + abs(y1 - y2)</code>由于蜂巢向上向下移动一次是 ± 0.5，所以得到最终的表达式为<code>abs(x1 - x2) + abs(y1 - y2) * 0.5</code>。</p><p>若一个点向上向下移动能直接抵达另一个点，那么直接输出<code>abs(y1- y2) * 0.5</code></p><h2 id="代码">代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0, 1, 2, 3, 4, 5</span></span><br><span class="line">directions = [[-<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">0.5</span>, <span class="number">1</span>], [<span class="number">0.5</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0.5</span>, -<span class="number">1</span>], [-<span class="number">0.5</span>, -<span class="number">1</span>]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">position</span>(<span class="params">d, p, q</span>):</span><br><span class="line">    pos_x = pos_y = <span class="number">0</span></span><br><span class="line">    pos_x += (directions[d][<span class="number">0</span>] * p) + (directions[(d + <span class="number">2</span>) % <span class="number">6</span>][<span class="number">0</span>] * q)</span><br><span class="line">    pos_y += (directions[d][<span class="number">1</span>] * p) + (directions[(d + <span class="number">2</span>) % <span class="number">6</span>][<span class="number">1</span>] * q)</span><br><span class="line">    <span class="keyword">return</span> pos_x, pos_y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">arr = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split()))</span><br><span class="line">d1, p1, q1 = arr[:<span class="number">3</span>]</span><br><span class="line">d2, p2, q2 = arr[<span class="number">3</span>:]</span><br><span class="line"></span><br><span class="line">B = position(d1, p1, q1)</span><br><span class="line">C = position(d2, p2, q2)</span><br><span class="line"></span><br><span class="line">x = <span class="built_in">abs</span>(B[<span class="number">0</span>] - C[<span class="number">0</span>])</span><br><span class="line">y = <span class="built_in">abs</span>(B[<span class="number">1</span>] - C[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> y * <span class="number">0.5</span> &gt;= x:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(y))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(x + y * <span class="number">0.5</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;这是蓝桥杯2022年Python的G题，其实这道题我在很久之前看到时被劝退，感觉自己写不出来，今天重新来挑战他，发现这道题没有运用任何变成知识，仅仅运用了直角坐标系(笛卡尔坐标系)。&lt;/p&gt;
&lt;p&gt;看到这一题的第一眼肯定不会将他和坐标系联系在一起，第一想到的时DFS和BFS</summary>
      
    
    
    
    <category term="蓝桥杯" scheme="https://www.nanjun-blog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
    <category term="2022" scheme="https://www.nanjun-blog.com/categories/%E8%93%9D%E6%A1%A5%E6%9D%AF/2022/"/>
    
    
    <category term="蓝桥杯" scheme="https://www.nanjun-blog.com/tags/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
    
  </entry>
  
  <entry>
    <title>LC343. 整数拆分</title>
    <link href="https://www.nanjun-blog.com/posts/10a5a7af.html"/>
    <id>https://www.nanjun-blog.com/posts/10a5a7af.html</id>
    <published>2023-02-16T14:18:02.000Z</published>
    <updated>2023-03-18T02:35:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>按照动规五部曲</p><ol><li><p>确定dp数组及其下标的含义</p><p>dp[i], i为要被拆分的整数，dp[i]为要被拆分的整数的最大乘积</p></li><li><p>确定递推公式</p><p>dp[i] = max(dp[i], j * (i - j), j * dp[i - j])</p><p>j * (i - j)是将数字拆分成两个正整数时的最大值</p><p>j * dp[i - j] 是将数字拆分成两个以上时的最大值，由于dp[i]前面以及被计算过了，所以可以直接得出拆分更多正整数的乘积</p></li><li><p>初始化dp数组</p><p>整数拆分0和1没有任何意义，所以只要关注2就行了,dp[2] = 1</p></li><li><p>确定遍历顺序</p><p>i从3开始遍历</p><p>j从1开始遍历</p></li><li><p>举例推导dp数组</p></li></ol><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">integerBreak</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i - <span class="number">1</span>):</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], (i - j) * j, dp[i - j] * j)</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(dp[i], <span class="built_in">max</span>(j * (i - j), j * dp[i - j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">integerBreak</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n + <span class="number">1</span>)</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">3</span>; i &lt; n + <span class="number">1</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">1</span>; j &lt; i - <span class="number">1</span>; j++ &#123;</span><br><span class="line">            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt;= b &#123;<span class="keyword">return</span> a&#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;按照动规五部曲&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;确定dp数组及其下标的含义&lt;/p&gt;
&lt;p&gt;dp[i], i为要被拆分的整数，dp[i]为要被拆分的整数的最大乘积&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定递推公式&lt;/p&gt;
&lt;p&gt;dp[i] = m</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="动态规划专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC63. 不同路径 II</title>
    <link href="https://www.nanjun-blog.com/posts/af94e356.html"/>
    <id>https://www.nanjun-blog.com/posts/af94e356.html</id>
    <published>2023-02-15T14:55:47.000Z</published>
    <updated>2023-03-18T02:35:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>与LC62大致相似，多了一个路障,遇到路障时候跳过，若上i - 1或者j - 1是路障则不添加路线</p><p>首先<code>dp[i][j]</code>肯定是能到这个位置的所有路径</p><p>递推公式：<code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></p><p>初始化：<code>dp[i][j] = 0</code></p><p>遍历顺序：顺序遍历</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePathsWithObstacles</span>(<span class="params">self, obstacleGrid: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        m = <span class="built_in">len</span>(obstacleGrid)</span><br><span class="line">        n = <span class="built_in">len</span>(obstacleGrid[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">if</span> obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        dp = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> obstacleGrid[i][j] == <span class="number">1</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i - <span class="number">1</span>][j] != <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> <span class="keyword">and</span> obstacleGrid[i][j - <span class="number">1</span>] != <span class="number">1</span>:</span><br><span class="line">                    dp[i][j] += dp[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br><span class="line">                </span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = obstacleGrid.<span class="built_in">size</span>(), n = obstacleGrid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span> (obstacleGrid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (obstacleGrid[i][j] == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i - <span class="number">1</span>][j] != <span class="number">1</span>) dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; obstacleGrid[i][j - <span class="number">1</span>] != <span class="number">1</span>) dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">func uniquePathsWithObstacles(obstacleGrid [][]int) int &#123;    m, n := len(obstacleGrid), len(obstacleGrid[0])    dp := make([][]int, m)    for i := range dp &#123;        dp[i] = make([]int, n)    &#125;    if obstacleGrid[0][0] == 1 &#123;return 0&#125;    dp[0][0] = 1    for i := 0; i &lt; m; i++ &#123;        for j := 0; j &lt; n; j++ &#123;            if obstacleGrid[i][j] == 1 &#123;continue&#125;            if i - 1 &gt;= 0 &amp;&amp; obstacleGrid[i - 1][j] != 1 &#123;                dp[i][j] += dp[i - 1][j]            &#125;            if j - 1 &gt;= 0 &amp;&amp; obstacleGrid[i][j - 1] != 1 &#123;                dp[i][j] += dp[i][j - 1]            &#125;        &#125;    &#125;    return dp[m - 1][n - 1]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;与LC62大致相似，多了一个路障,遇到路障时候跳过，若上i - 1或者j - 1是路障则不添加路线&lt;/p&gt;
&lt;p&gt;首先&lt;code&gt;dp[i][j]&lt;/code&gt;肯定是能到这个位置的所有路径&lt;/p&gt;
&lt;p&gt;递推公式：&lt;code&gt;dp[i][j] =</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="动态规划专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC62. 不同路径</title>
    <link href="https://www.nanjun-blog.com/posts/636fe572.html"/>
    <id>https://www.nanjun-blog.com/posts/636fe572.html</id>
    <published>2023-02-14T02:36:59.000Z</published>
    <updated>2023-03-18T02:35:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>题目给出了一个重要条件“机器人每次只能向下或者向右移动一步”由这个条件可以得出</p><ol><li>当前的路径和与他的左边和上边的路径有关。<code>[i - 1][j] 和 [i][j - 1]</code></li><li>dp使用二维数组,<code>dp[i][j]</code>能到此处的所有路径和</li><li>得出推导公式为: <code>dp[i][j] = dp[i - 1][j] + dp[i][j - 1]</code></li><li>遍历顺序：顺序遍历</li><li>初始化：<code>dp[0][0] = 1</code></li></ol><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        box = [[<span class="number">0</span>] * n <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(m)]</span><br><span class="line">        box[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> i == j == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= i - <span class="number">1</span>: box[i][j] += box[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= j - <span class="number">1</span>: box[i][j] += box[i][j - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> box[m - <span class="number">1</span>][n - <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) dp[i][j] += dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) dp[i][j] += dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">func uniquePaths(m int, n int) int &#123;    dp := make([][]int, m)    for i := range dp &#123;        dp[i] = make([]int, n)    &#125;    dp[0][0] = 1    for i := 0; i &lt; m; i++&#123;        for j := 0; j &lt; n; j++ &#123;            if j == 0 &amp;&amp; i == 0 &#123;continue&#125;            if 0 &lt;= i - 1 &#123;dp[i][j] += dp[i - 1][j]&#125;            if 0 &lt;= j - 1 &#123;dp[i][j] += dp[i][j - 1]&#125;        &#125;    &#125;    return dp[m - 1][n - 1]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;题目给出了一个重要条件“机器人每次只能向下或者向右移动一步”由这个条件可以得出&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当前的路径和与他的左边和上边的路径有关。&lt;code&gt;[i - 1][j] 和 [i][j - 1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;dp使用</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="动态规划专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC746. 使用最小花费爬楼梯</title>
    <link href="https://www.nanjun-blog.com/posts/67bc6ce2.html"/>
    <id>https://www.nanjun-blog.com/posts/67bc6ce2.html</id>
    <published>2023-02-13T06:12:13.000Z</published>
    <updated>2023-03-18T02:35:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>题目说从一个台阶向上爬需要付出cost[i]的费用，而每次只能爬1~2层台阶。</p><p>根据示例得出楼顶为cost[len(cost)]也就数组外。</p><p>由于每次只能爬1~2层台阶，那么我们可以直接从下标为3的地方开始顺序遍历。</p><p>递推公式：<code>dp[i] = min(dp[i - 1], dp[i - 2])</code></p><p>每次取前两个台阶的最小费用，这样就能达到最小费用了。</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">minCostClimbingStairs</span>(<span class="params">self, cost: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cost) == <span class="number">2</span>: <span class="keyword">return</span> <span class="built_in">min</span>(cost)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(cost)):</span><br><span class="line">            cost[i] += <span class="built_in">min</span>(cost[i - <span class="number">1</span>], cost[i - <span class="number">2</span>])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(cost[-<span class="number">1</span>], cost[-<span class="number">2</span>])</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cost.<span class="built_in">size</span>() == <span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">min</span>(cost[<span class="number">1</span>], cost[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; cost.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            cost[i] += <span class="built_in">min</span>(cost[i - <span class="number">1</span>], cost[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(cost[cost.<span class="built_in">size</span>() - <span class="number">1</span>], cost[cost.<span class="built_in">size</span>() - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GO">GO</h2><pre><code class="language-go">func minCostClimbingStairs(cost []int) int &#123;    if len(cost) == 2 &#123;return min(cost[0], cost[1])&#125;    n := len(cost)    for i := 2; i &lt; n; i++ &#123;        cost[i] += min(cost[i - 1], cost[i - 2])    &#125;    return min(cost[n - 1], cost[n - 2])&#125;func min(a int, b int) int &#123;    if a &lt;= b &#123;return a&#125;    return b&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;题目说从一个台阶向上爬需要付出cost[i]的费用，而每次只能爬1~2层台阶。&lt;/p&gt;
&lt;p&gt;根据示例得出楼顶为cost[len(cost)]也就数组外。&lt;/p&gt;
&lt;p&gt;由于每次只能爬1~2层台阶，那么我们可以直接从下标为3的地方开始顺序遍历。&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="动态规划专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC70. 爬楼梯</title>
    <link href="https://www.nanjun-blog.com/posts/965a672a.html"/>
    <id>https://www.nanjun-blog.com/posts/965a672a.html</id>
    <published>2023-02-13T05:32:14.000Z</published>
    <updated>2023-03-18T02:35:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>首先顶楼&lt;=2时直接返回n就行了</p><p>我们可以这么思考，每个台阶都是由他的前一个台阶和前前一个台阶上来的，而这两个台阶也是同理。</p><p>那么我们只要从前往后遍历(下标从3开始)，每次将当前台阶的前两个台阶加起来，那么就是当前台阶的方法</p><p>推导公式：dp[i] = dp[i - 1] + dp[i - 2]</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">climbStairs</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>, n + <span class="number">1</span>):</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> dp[n]</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GO">GO</h2><pre><code class="language-go">func climbStairs(n int) int &#123;    if n &lt;= 2 &#123;return n&#125;    dp := make([]int, n + 1, n + 1)    dp[1] = 1    dp[2] = 2    for i := 3; i &lt; n + 1; i++ &#123;        dp[i] = dp[i - 1] + dp[i - 2]    &#125;    return dp[n]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;首先顶楼&amp;lt;=2时直接返回n就行了&lt;/p&gt;
&lt;p&gt;我们可以这么思考，每个台阶都是由他的前一个台阶和前前一个台阶上来的，而这两个台阶也是同理。&lt;/p&gt;
&lt;p&gt;那么我们只要从前往后遍历(下标从3开始)，每次将当前台阶的前两个台阶加起来，那么就是当</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="动态规划专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC509. 斐波那契数</title>
    <link href="https://www.nanjun-blog.com/posts/9451dcc4.html"/>
    <id>https://www.nanjun-blog.com/posts/9451dcc4.html</id>
    <published>2023-02-13T05:31:34.000Z</published>
    <updated>2023-03-18T02:35:37.824Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>斐波那契数列为前两项的和，第0项和第1项分别为0， 1.</p><p>f(0) = 0f(1) = 1 f(2) = f(0) + f(1) = 1f(3) = f(2) + f(1) = 3</p><p>下标从2开始，从前往后遍历</p><p>f[n] = f[n - 1] + f[n - 2]</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">        <span class="keyword">if</span> n &lt;= <span class="number">1</span>: <span class="keyword">return</span> n</span><br><span class="line">        MOD = <span class="number">10</span> ** <span class="number">9</span> + <span class="number">7</span></span><br><span class="line">        fib = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line">        fib[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">            fib[i] = fib[i - <span class="number">1</span>] + fib[i - <span class="number">2</span>]</span><br><span class="line">        <span class="keyword">return</span> fib[-<span class="number">1</span>] % MOD</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> N = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            dp[i] %= N;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="GO">GO</h2><pre><code class="language-go">func fib(n int) int &#123;    if n &lt;= 1 &#123;return n&#125;    MOD := 1000000007    dp := make([]int, n + 1, n + 1)    dp[1] = 1    for i := 2; i &lt; n + 1; i++ &#123;        dp[i] = dp[i - 1] + dp[i - 2]        dp[i] %= MOD    &#125;    return dp[n]&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;斐波那契数列为前两项的和，第0项和第1项分别为0， 1.&lt;/p&gt;
&lt;p&gt;f(0) = 0	f(1) = 1 f(2) = f(0) + f(1) = 1	f(3) = f(2) + f(1) = 3&lt;/p&gt;
&lt;p&gt;下标从2开始，从前往后遍历&lt;/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="动态规划专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>对于回溯的一些理解</title>
    <link href="https://www.nanjun-blog.com/posts/816d7d9b.html"/>
    <id>https://www.nanjun-blog.com/posts/816d7d9b.html</id>
    <published>2023-02-11T11:35:52.000Z</published>
    <updated>2023-03-18T02:35:37.807Z</updated>
    
    <content type="html"><![CDATA[<p>个人感觉回溯与递归其实是差不多的，递归是由上到下的，而回溯是由下而上的。</p><p>回溯在部分题能变成记忆化搜索如果再得出递推公式就能变成DP(动态规划)了。</p><p>回溯主要的几个难点就在于剪枝</p><p>树层剪枝、树枝剪枝</p><p>数层剪枝我一般都是在每一层中使用一个哈希表，而树枝剪枝类似于有长度限制之类的，可以提前return</p><p>这段时间我的码力也是直线上升了，感觉到自己实力在不断的增长，我还自己做了一个小项目。</p><p>DataStructView相信不久就能做好</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;个人感觉回溯与递归其实是差不多的，递归是由上到下的，而回溯是由下而上的。&lt;/p&gt;
&lt;p&gt;回溯在部分题能变成记忆化搜索如果再得出递推公式就能变成DP(动态规划)了。&lt;/p&gt;
&lt;p&gt;回溯主要的几个难点就在于剪枝&lt;/p&gt;
&lt;p&gt;树层剪枝、树枝剪枝&lt;/p&gt;
&lt;p&gt;数层剪枝我一般都是</summary>
      
    
    
    
    <category term="碎碎念" scheme="https://www.nanjun-blog.com/categories/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
    
    <category term="碎碎念" scheme="https://www.nanjun-blog.com/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>LC37. 解数独</title>
    <link href="https://www.nanjun-blog.com/posts/1ca688a9.html"/>
    <id>https://www.nanjun-blog.com/posts/1ca688a9.html</id>
    <published>2023-02-11T11:24:48.000Z</published>
    <updated>2023-03-18T02:35:37.831Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveSudoku</span>(<span class="params">self, board: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">pos: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> valid</span><br><span class="line">            <span class="keyword">if</span> pos == <span class="built_in">len</span>(spaces):</span><br><span class="line">                valid = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            i, j = spaces[pos]</span><br><span class="line">            <span class="keyword">for</span> digit <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> line[i][digit] == column[j][digit] == block[i // <span class="number">3</span>][j // <span class="number">3</span>][digit] == <span class="literal">False</span>:</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i // <span class="number">3</span>][j // <span class="number">3</span>][digit] = <span class="literal">True</span></span><br><span class="line">                    board[i][j] = <span class="built_in">str</span>(digit + <span class="number">1</span>)</span><br><span class="line">                    dfs(pos + <span class="number">1</span>)</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i // <span class="number">3</span>][j // <span class="number">3</span>][digit] = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">if</span> valid:</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">        line = [[<span class="literal">False</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        column = [[<span class="literal">False</span>] * <span class="number">9</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>)]</span><br><span class="line">        block = [[[<span class="literal">False</span>] * <span class="number">9</span> <span class="keyword">for</span> _a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)] <span class="keyword">for</span> _b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>)]</span><br><span class="line">        valid = <span class="literal">False</span></span><br><span class="line">        spaces = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">9</span>):</span><br><span class="line">                <span class="keyword">if</span> board[i][j] == <span class="string">&quot;.&quot;</span>:</span><br><span class="line">                    spaces.append((i, j))</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    digit = <span class="built_in">int</span>(board[i][j]) - <span class="number">1</span></span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i // <span class="number">3</span>][j // <span class="number">3</span>][digit] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        dfs(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> line[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">bool</span> column[<span class="number">9</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">bool</span> block[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>];</span><br><span class="line">    <span class="type">bool</span> valid;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; spaces;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos == spaces.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            valid = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> [i, j] = spaces[pos];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> digit = <span class="number">0</span>; digit &lt; <span class="number">9</span> &amp;&amp; !valid; ++digit) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit]) &#123;</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                board[i][j] = digit + <span class="string">&#x27;0&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(board, pos + <span class="number">1</span>);</span><br><span class="line">                line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solveSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(line, <span class="literal">false</span>, <span class="built_in">sizeof</span>(line));</span><br><span class="line">        <span class="built_in">memset</span>(column, <span class="literal">false</span>, <span class="built_in">sizeof</span>(column));</span><br><span class="line">        <span class="built_in">memset</span>(block, <span class="literal">false</span>, <span class="built_in">sizeof</span>(block));</span><br><span class="line">        valid = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    spaces.<span class="built_in">emplace_back</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">int</span> digit = board[i][j] - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    line[i][digit] = column[j][digit] = block[i / <span class="number">3</span>][j / <span class="number">3</span>][digit] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(board, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">func solveSudoku(board [][]byte) &#123;    var line, column [9][9]bool    var block [3][3][9]bool    var spaces [][2]int    for i, row := range board &#123;        for j, b := range row &#123;            if b == '.' &#123;                spaces = append(spaces, [2]int&#123;i, j&#125;)            &#125; else &#123;                digit := b - '1'                line[i][digit] = true                column[j][digit] = true                block[i/3][j/3][digit] = true            &#125;        &#125;    &#125;    var dfs func(int) bool    dfs = func(pos int) bool &#123;        if pos == len(spaces) &#123;            return true        &#125;        i, j := spaces[pos][0], spaces[pos][1]        for digit := byte(0); digit &lt; 9; digit++ &#123;            if !line[i][digit] &amp;&amp; !column[j][digit] &amp;&amp; !block[i/3][j/3][digit] &#123;                line[i][digit] = true                column[j][digit] = true                block[i/3][j/3][digit] = true                board[i][j] = digit + '1'                if dfs(pos + 1) &#123;                    return true                &#125;                line[i][digit] = false                column[j][digit] = false                block[i/3][j/3][digit] = false            &#125;        &#125;        return false    &#125;    dfs(0)&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;h2 id=&quot;Python&quot;&gt;Python&lt;/h2&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC51. N 皇后</title>
    <link href="https://www.nanjun-blog.com/posts/cb00c34a.html"/>
    <id>https://www.nanjun-blog.com/posts/cb00c34a.html</id>
    <published>2023-02-11T11:17:21.000Z</published>
    <updated>2023-03-18T02:35:37.839Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>首先我们可以确定一下回溯传入值</p><p>backtracking(row: int, uMap: defaultdict(int), path:list[str])</p><p>这里row是行的意思，我们传入行不断的增加以达到每个皇后不在同一行上</p><p>uMap中key是col，value是row。</p><p>计算斜角是否在攻击范围内就是当前的row - preRow == col - preCol</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">solveNQueens</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">row: <span class="built_in">int</span>, umap:defaultdict(<span class="params"><span class="built_in">int</span></span>), path:<span class="built_in">list</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">            <span class="keyword">if</span> row == n:</span><br><span class="line">                result.append(path.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            s = [<span class="string">&#x27;.&#x27;</span>] * n</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, n):</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">                <span class="keyword">for</span> pre_col, pre_row <span class="keyword">in</span> umap.items():</span><br><span class="line">                    <span class="keyword">if</span> <span class="built_in">abs</span>(row - pre_row) == <span class="built_in">abs</span>(col - pre_col):</span><br><span class="line">                        flag = <span class="literal">True</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                <span class="keyword">if</span> col <span class="keyword">in</span> umap: <span class="keyword">continue</span>  <span class="comment"># 该列会被攻击到</span></span><br><span class="line">                <span class="keyword">if</span> flag: <span class="keyword">continue</span>  <span class="comment"># 会被斜角攻击到</span></span><br><span class="line">                s[col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">                umap[col] = row</span><br><span class="line">                path.append(<span class="string">&quot;&quot;</span>.join(s))</span><br><span class="line">                backtracking(row + <span class="number">1</span>, umap, path)</span><br><span class="line">                s[col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">                path.pop()</span><br><span class="line">                umap.pop(col)</span><br><span class="line">        </span><br><span class="line">        backtracking(<span class="number">0</span>, defaultdict(<span class="built_in">int</span>), [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">solveNQueens</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">col</span><span class="params">(n)</span>, <span class="title">on_path</span><span class="params">(n)</span>, <span class="title">diag1</span><span class="params">(n * <span class="number">2</span> - <span class="number">1</span>)</span>, <span class="title">diag2</span><span class="params">(n * <span class="number">2</span> - <span class="number">1</span>)</span></span>;</span><br><span class="line">        function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == n) &#123;</span><br><span class="line">                vector&lt;string&gt; <span class="built_in">board</span>(n);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                    board[i] = <span class="built_in">string</span>(col[i], <span class="string">&#x27;.&#x27;</span>) + <span class="string">&#x27;Q&#x27;</span> + <span class="built_in">string</span>(n - <span class="number">1</span> - col[i], <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(board);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; ++c) &#123;</span><br><span class="line">                <span class="type">int</span> rc = r - c + n - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!on_path[c] &amp;&amp; !diag1[r + c] &amp;&amp; !diag2[rc]) &#123;</span><br><span class="line">                    col[r] = c;</span><br><span class="line">                    on_path[c] = diag1[r + c] = diag2[rc] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="built_in">dfs</span>(r + <span class="number">1</span>);</span><br><span class="line">                    on_path[c] = diag1[r + c] = diag2[rc] = <span class="literal">false</span>; <span class="comment">// 恢复现场</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result [][]<span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> path []<span class="type">string</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">solveNQueens</span><span class="params">(n <span class="type">int</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    result = [][]<span class="type">string</span>&#123;&#125;</span><br><span class="line">    path = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    umap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    backtracking(<span class="number">0</span>, umap, n)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtracking</span><span class="params">(row <span class="type">int</span>, umap <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>, n <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> row == n &#123;</span><br><span class="line">        t := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="built_in">len</span>(path))</span><br><span class="line">        <span class="built_in">copy</span>(t, path)</span><br><span class="line">        result = <span class="built_in">append</span>(result, t)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">rune</span>, n, n)</span><br><span class="line">    <span class="keyword">for</span> i, _ := <span class="keyword">range</span> s &#123;</span><br><span class="line">        s[i] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> col := <span class="number">0</span>; col &lt; n; col++ &#123;</span><br><span class="line">        _, ok := umap[col]</span><br><span class="line">        flag := <span class="literal">false</span></span><br><span class="line">        <span class="keyword">for</span> pre_col, pre_row := <span class="keyword">range</span> umap &#123;</span><br><span class="line">            <span class="keyword">if</span> abs(row - pre_row) == abs(col - pre_col) &#123;</span><br><span class="line">                flag = <span class="literal">true</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> flag &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> ok &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line">        s[col] = <span class="string">&#x27;Q&#x27;</span></span><br><span class="line">        umap[col] = row</span><br><span class="line">        path = <span class="built_in">append</span>(path, <span class="type">string</span>(s))</span><br><span class="line">        backtracking(row + <span class="number">1</span>, umap, n)</span><br><span class="line">        s[col] = <span class="string">&#x27;.&#x27;</span></span><br><span class="line">        <span class="built_in">delete</span>(umap, col)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">abs</span><span class="params">(a <span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; <span class="number">0</span> &#123;<span class="keyword">return</span> -a&#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;首先我们可以确定一下回溯传入值&lt;/p&gt;
&lt;p&gt;backtracking(row: int, uMap: defaultdict(int), path:list[str])&lt;/p&gt;
&lt;p&gt;这里row是行的意思，我们传入行不断的增加以达到每个皇后不在</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC491. 递增子序列</title>
    <link href="https://www.nanjun-blog.com/posts/ad1605e2.html"/>
    <id>https://www.nanjun-blog.com/posts/ad1605e2.html</id>
    <published>2023-02-10T15:25:05.000Z</published>
    <updated>2023-03-18T02:35:37.834Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>题目要求子序列至少2个元素且递增，那么我们添加条件可以是当<code>path</code>中有两个元素的时候</p><p>使用哈希表记录当前层使用过的元素，若再次碰到直接continue</p><p>当nums[i] &lt; path的最后一个元素时则continue</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">findSubsequences</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">startIndex: <span class="built_in">int</span>, path: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(path) &gt;= <span class="number">2</span>:</span><br><span class="line">                result.append(path.copy())</span><br><span class="line">            uset = <span class="built_in">set</span>()</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> path <span class="keyword">and</span> nums[i] &lt; path[-<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">in</span> uset: <span class="keyword">continue</span></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                uset.add(nums[i])</span><br><span class="line">                backtracking(i + <span class="number">1</span>, path)</span><br><span class="line">                path.pop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        backtracking(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (path.<span class="built_in">size</span>() &gt; <span class="number">1</span>) result.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!path.<span class="built_in">empty</span>() &amp;&amp; nums[i] &lt; path[path.<span class="built_in">size</span>() - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (uset.<span class="built_in">find</span>(nums[i]) != uset.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            uset.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(i + <span class="number">1</span>, nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">findSubsequences</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        result.<span class="built_in">clear</span>();</span><br><span class="line">        path.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">var result [][]intvar path []intfunc findSubsequences(nums []int) [][]int &#123;    result = [][]int&#123;&#125;    path = []int&#123;&#125;    backtracking(0, nums)    return result&#125;func backtracking(startIndex int, nums []int) &#123;    if len(path) &gt; 1 &#123;        t := make([]int, len(path))        copy(t, path)        result = append(result, t)    &#125;    uset := make(map[int]bool)    for i := startIndex; i &lt; len(nums); i++ &#123;        if len(path) != 0 &amp;&amp; nums[i] &lt; path[len(path) - 1] &#123;continue&#125;        if uset[nums[i]] == true &#123;continue&#125;        path = append(path, nums[i])        uset[nums[i]] = true        backtracking(i + 1, nums)        path = path[:len(path) - 1]    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;题目要求子序列至少2个元素且递增，那么我们添加条件可以是当&lt;code&gt;path&lt;/code&gt;中有两个元素的时候&lt;/p&gt;
&lt;p&gt;使用哈希表记录当前层使用过的元素，若再次碰到直接continue&lt;/p&gt;
&lt;p&gt;当nums[i] &amp;lt; path的最</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC90. 子集 II</title>
    <link href="https://www.nanjun-blog.com/posts/8d0fcb67.html"/>
    <id>https://www.nanjun-blog.com/posts/8d0fcb67.html</id>
    <published>2023-02-10T15:24:44.000Z</published>
    <updated>2023-03-18T02:35:37.836Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>与子集(LC79)不同的是数组中有重复的元素，题目要求我们的解集中不包含重复子集，有两种解法。</p><ol><li>哈希表</li><li>排序</li></ol><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsetsWithDup</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        nums.sort()</span><br><span class="line">        result = [[]]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">startIndex: <span class="built_in">int</span>, path: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(nums): <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span> i &gt; startIndex <span class="keyword">and</span> nums[i - <span class="number">1</span>] == nums[i]: <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">                path.append(nums[i])</span><br><span class="line">                result.append(path.copy())</span><br><span class="line">                dfs(i + <span class="number">1</span>, path)</span><br><span class="line">                path.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>, result, path, nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> startIndex, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;result, vector&lt;<span class="type">int</span>&gt; &amp;path, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; startIndex &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="built_in">backtracking</span>(i + <span class="number">1</span>, result, path, nums);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">var result [][]intfunc subsetsWithDup(nums []int) [][]int &#123;    result = [][]int&#123;&#125;    result = append(result, []int&#123;&#125;)    sort.Ints(nums)    backtracking(0, []int&#123;&#125;, nums)    return result&#125;func backtracking(startIndex int, path []int, nums []int) &#123;    for i := startIndex; i &lt; len(nums); i++ &#123;        if i &gt; startIndex &amp;&amp; nums[i] == nums[i - 1] &#123;continue&#125;        path = append(path, nums[i])        t := make([]int, len(path))        copy(t, path)        result = append(result, t)        backtracking(i + 1, path, nums)        path = path[:len(path) - 1]    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;与子集(LC79)不同的是数组中有重复的元素，题目要求我们的解集中不包含重复子集，有两种解法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哈希表&lt;/li&gt;
&lt;li&gt;排序&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;h2 id=&quot;Python&quot;&gt;Python&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LC78. 子集</title>
    <link href="https://www.nanjun-blog.com/posts/7eb25fda.html"/>
    <id>https://www.nanjun-blog.com/posts/7eb25fda.html</id>
    <published>2023-02-10T15:24:18.000Z</published>
    <updated>2023-03-18T02:35:37.834Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>将<code>nums</code>数组所有子集添加进去就行</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subsets</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        result = [[]]</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">dfs</span>(<span class="params">startIndex: <span class="built_in">int</span>, temp: <span class="built_in">list</span>[<span class="built_in">int</span>]</span>):</span><br><span class="line">            <span class="keyword">if</span> startIndex == <span class="built_in">len</span>(nums): <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, <span class="built_in">len</span>(nums)):</span><br><span class="line">                temp.append(nums[i])</span><br><span class="line">                result.append(temp.copy())</span><br><span class="line">                dfs(i + <span class="number">1</span>, temp)</span><br><span class="line">                temp.pop()</span><br><span class="line">        </span><br><span class="line">        dfs(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        result.<span class="built_in">push_back</span>(temp);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">backtracking</span>(<span class="number">0</span>, temp, result, nums);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> startIndex, vector&lt;<span class="type">int</span>&gt; &amp;temp, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;result, vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (startIndex == nums.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = startIndex; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="built_in">backtracking</span>(i + <span class="number">1</span>, temp, result, nums);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">var result [][]intfunc subsets(nums []int) [][]int &#123;    result = [][]int&#123;&#125;    result = append(result, []int&#123;&#125;)    backtracking(0, []int&#123;&#125;, nums)    return result&#125;func backtracking(startIndex int, temp []int, nums []int) &#123;    if startIndex == len(nums) &#123;return&#125;    for i := startIndex; i &lt; len(nums); i++ &#123;        temp = append(temp, nums[i])        t := make([]int, len(temp))        copy(t, temp)        result = append(result, t)        backtracking(i + 1, temp, nums)        temp = temp[:len(temp) - 1]    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;将&lt;code&gt;nums&lt;/code&gt;数组所有子集添加进去就行&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;h2 id=&quot;Python&quot;&gt;Python&lt;/h2&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td </summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC93. 复原 IP 地址</title>
    <link href="https://www.nanjun-blog.com/posts/8fddc6e7.html"/>
    <id>https://www.nanjun-blog.com/posts/8fddc6e7.html</id>
    <published>2023-02-10T15:23:58.000Z</published>
    <updated>2023-03-18T02:35:37.836Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>这题考点就是剪枝</p><ol><li><p>如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</p></li><li><p>如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</p></li><li><p>由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</p></li></ol><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">restoreIpAddresses</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">str</span>]:</span><br><span class="line">        <span class="comment"># 4 * 3 = 12</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(s) &gt; <span class="number">12</span>: <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">startIndex: <span class="built_in">int</span>, temp: <span class="built_in">list</span>[<span class="built_in">str</span>]</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s):</span><br><span class="line">                    result.append(<span class="string">&quot;.&quot;</span>.join(temp))</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            c = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startIndex, startIndex + <span class="number">3</span>):</span><br><span class="line">                <span class="keyword">if</span> i &gt;= <span class="built_in">len</span>(s): <span class="keyword">return</span></span><br><span class="line">                c += s[i]</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(c) &gt; <span class="number">1</span> <span class="keyword">and</span> c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>: <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> <span class="number">0</span> &lt;= <span class="built_in">int</span>(c) &lt;= <span class="number">255</span>:</span><br><span class="line">                    temp.append(c)</span><br><span class="line">                    backtracking(i + <span class="number">1</span>, temp)</span><br><span class="line">                    temp.pop()</span><br><span class="line">        </span><br><span class="line">        backtracking(<span class="number">0</span>, [])</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> SEG_COUNT = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; segments;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> segId, <span class="type">int</span> segStart)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案</span></span><br><span class="line">        <span class="keyword">if</span> (segId == SEG_COUNT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                string ipAddr;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; SEG_COUNT; ++i) &#123;</span><br><span class="line">                    ipAddr += <span class="built_in">to_string</span>(segments[i]);</span><br><span class="line">                    <span class="keyword">if</span> (i != SEG_COUNT - <span class="number">1</span>) &#123;</span><br><span class="line">                        ipAddr += <span class="string">&quot;.&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">move</span>(ipAddr));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯</span></span><br><span class="line">        <span class="keyword">if</span> (segStart == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0</span></span><br><span class="line">        <span class="keyword">if</span> (s[segStart] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            segments[segId] = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segStart + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一般情况，枚举每一种可能性并递归</span></span><br><span class="line">        <span class="type">int</span> addr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> segEnd = segStart; segEnd &lt; s.<span class="built_in">size</span>(); ++segEnd) &#123;</span><br><span class="line">            addr = addr * <span class="number">10</span> + (s[segEnd] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (addr &gt; <span class="number">0</span> &amp;&amp; addr &lt;= <span class="number">0xFF</span>) &#123;</span><br><span class="line">                segments[segId] = addr;</span><br><span class="line">                <span class="built_in">dfs</span>(s, segId + <span class="number">1</span>, segEnd + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">restoreIpAddresses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        segments.<span class="built_in">resize</span>(SEG_COUNT);</span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIpAddresses</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">    result = []<span class="type">string</span>&#123;&#125;</span><br><span class="line">    backtracking(s, <span class="number">0</span>, []<span class="type">string</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtracking</span><span class="params">(s <span class="type">string</span>, startIndex <span class="type">int</span>, temp []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(temp) == <span class="number">4</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> startIndex &gt;= <span class="built_in">len</span>(s) &#123;</span><br><span class="line">            result = <span class="built_in">append</span>(result, strings.Join(temp, <span class="string">&quot;.&quot;</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    c := <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> i := startIndex; i &lt; startIndex + <span class="number">3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="built_in">len</span>(s) &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        c += <span class="type">string</span>(s[i])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(c) &gt; <span class="number">1</span> &amp;&amp; c[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &#123;<span class="keyword">return</span>&#125;</span><br><span class="line">        num, _ := strconv.Atoi(c)</span><br><span class="line">        <span class="keyword">if</span> num &gt;= <span class="number">0</span> &amp;&amp; num &lt;= <span class="number">255</span> &#123;</span><br><span class="line">            temp = <span class="built_in">append</span>(temp, c)</span><br><span class="line">            backtracking(s, i + <span class="number">1</span>, temp)</span><br><span class="line">            temp = temp[:<span class="built_in">len</span>(temp) - <span class="number">1</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;这题考点就是剪枝&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯&lt;/p&gt;
&lt;/li&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LC131. 分割回文串</title>
    <link href="https://www.nanjun-blog.com/posts/c84b6fba.html"/>
    <id>https://www.nanjun-blog.com/posts/c84b6fba.html</id>
    <published>2023-02-10T15:23:22.000Z</published>
    <updated>2023-03-18T02:35:37.830Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>首先需要一个check函数用来验证字符串是否为回文串，这里check我们选用双指针。</p><p>从下标0开始不断查找回文串，当下标到达s长度时添加进<code>result</code></p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span><br><span class="line">        result = []</span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">s: <span class="built_in">str</span></span>):</span><br><span class="line">            l, r = <span class="number">0</span>, <span class="built_in">len</span>(s) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">                <span class="keyword">if</span> s[l] != s[r]: <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">temp: <span class="built_in">list</span>[<span class="built_in">str</span>], start: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> start == <span class="built_in">len</span>(s):</span><br><span class="line">                result.append(temp.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            sub = <span class="string">&quot;&quot;</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(s)):</span><br><span class="line">                sub += s[i]</span><br><span class="line">                <span class="keyword">if</span> check(sub):</span><br><span class="line">                    temp.append(sub)</span><br><span class="line">                    backtracking(temp, i + <span class="number">1</span>)</span><br><span class="line">                    temp.pop()</span><br><span class="line"></span><br><span class="line">        backtracking([], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; f;</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; ret;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; s, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            ret.<span class="built_in">push_back</span>(ans);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f[i][j]) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(i, j - i + <span class="number">1</span>));</span><br><span class="line">                <span class="built_in">dfs</span>(s, j + <span class="number">1</span>);</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">partition</span>(string s) &#123;</span><br><span class="line">        n = s.<span class="built_in">size</span>();</span><br><span class="line">        f.<span class="built_in">assign</span>(n, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="literal">true</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = (s[i] == s[j]) &amp;&amp; f[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">func partition(s string) (ans [][]string) &#123;    n := len(s)    f := make([][]int8, n)    for i := range f &#123;        f[i] = make([]int8, n)    &#125;    // 0 表示尚未搜索，1 表示是回文串，-1 表示不是回文串    var isPalindrome func(i, j int) int8    isPalindrome = func(i, j int) int8 &#123;        if i &gt;= j &#123;            return 1        &#125;        if f[i][j] != 0 &#123;            return f[i][j]        &#125;        f[i][j] = -1        if s[i] == s[j] &#123;            f[i][j] = isPalindrome(i+1, j-1)        &#125;        return f[i][j]    &#125;    splits := []string&#123;&#125;    var dfs func(int)    dfs = func(i int) &#123;        if i == n &#123;            ans = append(ans, append([]string(nil), splits...))            return        &#125;        for j := i; j &lt; n; j++ &#123;            if isPalindrome(i, j) &gt; 0 &#123;                splits = append(splits, s[i:j+1])                dfs(j + 1)                splits = splits[:len(splits)-1]            &#125;        &#125;    &#125;    dfs(0)    return&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;首先需要一个check函数用来验证字符串是否为回文串，这里check我们选用双指针。&lt;/p&gt;
&lt;p&gt;从下标0开始不断查找回文串，当下标到达s长度时添加进&lt;code&gt;result&lt;/code&gt;&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;h2 id=&quot;Pyt</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC40. 组合总和 II</title>
    <link href="https://www.nanjun-blog.com/posts/c71a0e34.html"/>
    <id>https://www.nanjun-blog.com/posts/c71a0e34.html</id>
    <published>2023-02-10T15:22:58.000Z</published>
    <updated>2023-03-18T02:35:37.834Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>这题与组合总和(LC39)的区别在于给的<code>candidates</code>中有重复的元素，题目要求每个数字在一个组合中只能使用一次，那么这里有两种方法，第一种就是直接使用哈希表记录元素，第二种则比较简单，使用<code>startIndex</code>，由于<code>candidates</code>在开始已经被排序了，那么只要</p><p><code>i &gt; startIndex 且 nums[i] == nums[i - 1]</code>时可以直接continue避免使用重复元素</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum2</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        candidates.sort()</span><br><span class="line">        answer = []</span><br><span class="line">        temp = []</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">start: <span class="built_in">int</span>, s: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                answer.append(temp.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> s + candidates[i] &gt; target: <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">if</span> i &gt; start <span class="keyword">and</span> candidates[i] == candidates[i -<span class="number">1</span>]: <span class="keyword">continue</span></span><br><span class="line">                temp.append(candidates[i])</span><br><span class="line">                backtracking(i + <span class="number">1</span>, s + candidates[i])</span><br><span class="line">                temp.pop()</span><br><span class="line">        </span><br><span class="line">        backtracking(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; answer;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            answer.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>() &amp;&amp; sum + candidates[i] &lt;= target; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; candidates[i] == candidates[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i + <span class="number">1</span>, sum + candidates[i]);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">var (    answer [][]int    temp []int)func combinationSum2(candidates []int, target int) [][]int &#123;    answer = [][]int&#123;&#125;    temp = []int&#123;&#125;    sort.Ints(candidates)    backtracking(candidates, target, 0, 0)    return answer&#125;func backtracking(candidates []int, target int, start int, sum int) &#123;    if sum == target &#123;        t := make([]int, len(temp))        copy(t, temp)        answer = append(answer, t)        return    &#125;    for i := start; i &lt; len(candidates) &amp;&amp; sum + candidates[i] &lt;= target; i++ &#123;        if i &gt; start &amp;&amp; candidates[i] == candidates[i - 1] &#123;continue&#125;        temp = append(temp, candidates[i])        backtracking(candidates, target, i + 1, sum + candidates[i])        temp = temp[:len(temp) - 1]    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;这题与组合总和(LC39)的区别在于给的&lt;code&gt;candidates&lt;/code&gt;中有重复的元素，题目要求每个数字在一个组合中只能使用一次，那么这里有两种方法，第一种就是直接使用哈希表记录元素，第二种则比较简单，使用&lt;code&gt;startIn</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC39. 组合总和</title>
    <link href="https://www.nanjun-blog.com/posts/e07e0300.html"/>
    <id>https://www.nanjun-blog.com/posts/e07e0300.html</id>
    <published>2023-02-10T15:22:32.000Z</published>
    <updated>2023-03-18T02:35:37.831Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>这题就是排序直接使用回溯，考点可能就是几个剪枝的地方。</p><ol><li>当总和 &gt; target时</li></ol><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum</span>(<span class="params">self, candidates: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        answer = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">start: <span class="built_in">int</span>, temp: <span class="built_in">list</span>[<span class="built_in">int</span>], s: <span class="built_in">int</span></span>):</span><br><span class="line">            <span class="keyword">if</span> s == target:</span><br><span class="line">                answer.append(temp.copy())</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(start, <span class="built_in">len</span>(candidates)):</span><br><span class="line">                <span class="keyword">if</span> s + candidates[i] &gt; target: <span class="keyword">return</span></span><br><span class="line">                temp.append(candidates[i])</span><br><span class="line">                backtracking(i, temp, s + candidates[i])</span><br><span class="line">                temp.pop()</span><br><span class="line">        </span><br><span class="line">        candidates.sort()</span><br><span class="line">        backtracking(<span class="number">0</span>, [], <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; answer;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(), candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtracking</span>(candidates, target, <span class="number">0</span>, <span class="number">0</span>, temp, answer);</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;candidates, <span class="type">int</span> target, <span class="type">int</span> start, <span class="type">int</span> sum, vector&lt;<span class="type">int</span>&gt; temp, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;answer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">            answer.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt; candidates.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum + candidates[i] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(candidates[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(candidates, target, i, sum + candidates[i], temp, answer);</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">func combinationSum(candidates []int, target int) [][]int &#123;    answer := make([][]int, 0, 0)    sort.Ints(candidates)    backtracking(candidates, target, 0, make([]int, 0, 0), 0, &amp;answer)    return answer&#125;func backtracking(candidates []int, target int, start int, temp []int, sum int, answer *[][]int) &#123;    if sum == target &#123;        t := make([]int, len(temp))        copy(t, temp)        *answer = append(*answer, t)        return    &#125;    for i := start; i &lt; len(candidates); i++ &#123;        if sum + candidates[i] &gt; target &#123;return&#125;        temp = append(temp, candidates[i])        backtracking(candidates, target, i, temp, sum + candidates[i], answer)        temp = temp[:len(temp) - 1]    &#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;这题就是排序直接使用回溯，考点可能就是几个剪枝的地方。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当总和 &amp;gt; target时&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;h2 id=&quot;Python&quot;&gt;Python&lt;/h2&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC216. 组合总和 III</title>
    <link href="https://www.nanjun-blog.com/posts/fe0cac34.html"/>
    <id>https://www.nanjun-blog.com/posts/fe0cac34.html</id>
    <published>2023-02-10T15:21:35.000Z</published>
    <updated>2023-03-18T02:35:37.831Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>就是按照题目要求从1开始遍历到9，当发现可以数组内的和达到n时就添加至<code>result</code>,若数组长度超过<code>k</code>则回溯。</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">combinationSum3</span>(<span class="params">self, k: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        ans = []</span><br><span class="line">        temp = []</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">backtracking</span>(<span class="params">num, s</span>):</span><br><span class="line">            <span class="keyword">nonlocal</span> temp</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(temp) == k <span class="keyword">and</span> s == n:</span><br><span class="line">                ans.append(temp.copy())</span><br><span class="line">            <span class="keyword">elif</span> <span class="built_in">len</span>(temp) == k: <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">elif</span> s &gt; n: <span class="keyword">return</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> number <span class="keyword">in</span> <span class="built_in">range</span>(num, <span class="number">10</span>):</span><br><span class="line">                temp.append(number)</span><br><span class="line">                s += number</span><br><span class="line">                backtracking(number + <span class="number">1</span>, s)</span><br><span class="line">                s -= temp.pop()</span><br><span class="line">        backtracking(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum3</span>(<span class="type">int</span> k, <span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="built_in">backtracking</span>(k, n, <span class="number">1</span>, <span class="number">0</span>, ans, temp);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtracking</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> n, <span class="type">int</span> num, <span class="type">int</span> s, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans, vector&lt;<span class="type">int</span>&gt; temp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (temp.<span class="built_in">size</span>() == k &amp;&amp; s == n) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(temp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp.<span class="built_in">size</span>() == k) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x = num; x &lt; <span class="number">10</span>; ++x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s + x &gt; n) <span class="keyword">return</span>;</span><br><span class="line">            temp.<span class="built_in">push_back</span>(x);</span><br><span class="line">            s += x;</span><br><span class="line">            <span class="built_in">backtracking</span>(k, n, x + <span class="number">1</span>, s, ans, temp);</span><br><span class="line">            s -= x;</span><br><span class="line">            temp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><pre><code class="language-go">func combinationSum3(k int, n int) [][]int &#123;    ans := make([][]int, 0, 0)    temp := make([]int, 0, 0)    backtracking(k, n, 1, 0, &amp;ans, temp)    return ans&#125;func backtracking(k int, n int, num int, s int, ans *[][]int, temp []int) &#123;if len(temp) == k &amp;&amp; s == n &#123;        t := make([]int, k)copy(t, temp)*ans = append(*ans, t)return&#125; else if len(temp) == k &#123;return&#125;for x := num; x &lt; 10; x++ &#123;if s+x &gt; n &#123;return&#125;s += xtemp = append(temp, x)backtracking(k, n, x + 1, s, ans, temp)temp = temp[:len(temp)-1]s -= x&#125;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;就是按照题目要求从1开始遍历到9，当发现可以数组内的和达到n时就添加至&lt;code&gt;result&lt;/code&gt;,若数组长度超过&lt;code&gt;k&lt;/code&gt;则回溯。&lt;/p&gt;
&lt;h1&gt;代码&lt;/h1&gt;
&lt;h2 id=&quot;Python&quot;&gt;Python&lt;/h2</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LC47. 全排列 II</title>
    <link href="https://www.nanjun-blog.com/posts/e206752e.html"/>
    <id>https://www.nanjun-blog.com/posts/e206752e.html</id>
    <published>2023-02-10T15:18:15.000Z</published>
    <updated>2023-03-18T02:35:37.834Z</updated>
    
    <content type="html"><![CDATA[<h1>解题思路</h1><p>这题大概的代码与全排列(LC46)差不多,它们的区别是给定的<code>nums</code>中包含重复的元素，那么我们在遍历的时候要记录当前这层是否已经使用过某个元素了，如果已经使用过了则跳过。同样使用的是哈希表，不过这次记录的不是下标而是元素值。</p><h1>代码</h1><h2 id="Python">Python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">permuteUnique</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(permutations(nums)))</span><br></pre></td></tr></table></figure><h2 id="C">C++</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, <span class="type">int</span> idx, vector&lt;<span class="type">int</span>&gt;&amp; perm)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(perm);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !vis[i - <span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            perm.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            vis[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">backtrack</span>(nums, ans, idx + <span class="number">1</span>, perm);</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            perm.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; perm;</span><br><span class="line">        vis.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, ans, <span class="number">0</span>, perm);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Go">Go</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result [][]<span class="type">int</span></span><br><span class="line"><span class="keyword">var</span> path []<span class="type">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(nums []<span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    result = [][]<span class="type">int</span>&#123;&#125;</span><br><span class="line">    path = []<span class="type">int</span>&#123;&#125;</span><br><span class="line">    m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    backtracking(nums, m)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">backtracking</span><span class="params">(nums []<span class="type">int</span>, m <span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(path) == <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        t := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(path))</span><br><span class="line">        <span class="built_in">copy</span>(t, path)</span><br><span class="line">        result = <span class="built_in">append</span>(result, t)</span><br><span class="line">    &#125;</span><br><span class="line">    uset := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> m[i] == <span class="literal">true</span> &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line">        <span class="keyword">if</span> uset[nums[i]] == <span class="literal">true</span> &#123;<span class="keyword">continue</span>&#125;</span><br><span class="line">        m[i] = <span class="literal">true</span></span><br><span class="line">        uset[nums[i]] = <span class="literal">true</span></span><br><span class="line">        path = <span class="built_in">append</span>(path, nums[i])</span><br><span class="line">        backtracking(nums, m)</span><br><span class="line">        path = path[:<span class="built_in">len</span>(path) - <span class="number">1</span>]</span><br><span class="line">        m[i] = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;解题思路&lt;/h1&gt;
&lt;p&gt;这题大概的代码与全排列(LC46)差不多,它们的区别是给定的&lt;code&gt;nums&lt;/code&gt;中包含重复的元素，那么我们在遍历的时候要记录当前这层是否已经使用过某个元素了，如果已经使用过了则跳过。同样使用的是哈希表，不过这次记录的不是下标而是元素</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/categories/LeetCode/"/>
    
    <category term="回溯专题" scheme="https://www.nanjun-blog.com/categories/LeetCode/%E5%9B%9E%E6%BA%AF%E4%B8%93%E9%A2%98/"/>
    
    
    <category term="LeetCode" scheme="https://www.nanjun-blog.com/tags/LeetCode/"/>
    
  </entry>
  
</feed>
